
.MODEL SMALL
.STACK 100H
.DATA

MESSAGE1 DB 'ENTER UP TO 10 ELEMENTS : $' 
MESSAGE2 DB 'AFTER SORTING : $'
MESSAGE3 DB 'PRESS : 1-FOR DESCENDING ORDER  2-FOR ASCENDING ORDER  $'
MESSAGE4 DB 'INVALID NUMBER $'
MESSAGE5 DB 'PRESS : 1-FOR BUBBLE SORTING  2-FOR SELECTION SORTING 3- QUICK SORT $'
MESSAGE6 DB 'YOU MUST ENTER ELEMENTS FIRST $'
 
 
ARR DB 10 dup (0) 
 
 i db  ? 
 j db  ?
 left db  0                           
 right db  ?  ;this will be the index of thr right(last) element                         
 q db  ?      ;this equal the return value from parttion
 x db  ?      ;this will carry the value of arr[right]

.CODE  
  
 
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX 
       
    CALL NEW_LINE
    MOV AH,9       ;DISPLAY MESSAGE
    lea DX,MESSAGE1
    INT 21H
    MOV CX,0 
    ;FILLING ARRAY
    MOV AH,1 ;FIRST INPUT
    INT 21H
    MOV SI,0
    WHILE_:
        CMP AL,0DH      ;COMPARE INPUT WITH CR ;ENTER BUTTON
        JE END_WHILE    ;IF EQUAL JMP TO END_WHILE
        MOV ARR[SI],AL ;MOVE INPUT INTO ARRAY
        INC SI          ;SI+=1
        INC CX
        CMP CX,10
        JE END_WHILE
        CALL PRINT_SPACE
        MOV AH,1
        INT 21H
                
    JMP WHILE_          ;JMP WHILE_ TO CONTINUE ENTER THE INPUTS
    END_WHILE:
    CALL NEW_LINE
    JCXZ NO_INPUTS_MESSAGE ;IF CX == 0 JMP NO_INPUTS_MESSAGE LABLE (THIS CONDITION IF NO INPUTS ENTERED) 
    
    LEA SI,ARR ;OFFSET OF ARRAY INTO SI
    MOV BX,CX 
    
    MOV right,Cl ;mov the number of elements into thr r variable
    DEC right    ;decrement to get index of the last(right) element of the array
    
    PUSH CX ;push number of elements
    
    
   ;CHOOSE THE TYPE OF SORTING
    CALL NEW_LINE
    MOV AH,9
    LEA DX,MESSAGE5     ;print message5
    INT 21H
    CALL NEW_LINE 
    
    MOV AH,1
    INT 21H       ;enter a number
    SUB AL,30H 
    CMP AL,1      ;COMPARE INPUT WITH 1
    JB INVALID 
    JE T1    ;IF EQUAL JMP TO T1 WHICH CONTAIN THE CODE OF THE BUBBLE SORT 
    CMP AL,2      ;COMPARE INPUT WITH 2
    JE T2    ;IF EQUAL JMP TO T2 WHICH CONTAIN THE CODE OF THE SELECTION SORT
    CMP AL,3      ;COMPARE INPUT WITH 2
    JA INVALID
    JE T3    ;IF EQUAL JMP TO T2 WHICH CONTAIN THE CODE OF THE QUICK SORT
    
    
    
    
       T1: ;BUBBLE TYPE
    ;CHOOSE THE TYPE OF ORDER ASCENDING OR DESCENDING
    CALL NEW_LINE 
    MOV AH,9
    LEA DX,MESSAGE3     ;print message3
    INT 21H
    CALL NEW_LINE 
    
    MOV AH,1
    INT 21H          ;enter a number
    SUB AL,30H 
    CMP AL,1      ;COMPARE INPUT WITH 1
    JB INVALID 
    JE P1    ;IF EQUAL JMP TO P1 AND THEN CALL DESCENDING SORT
    CMP AL,2      ;COMPARE INPUT WITH 2
    JA INVALID
    JE P2    ;IF EQUAL JMP TO P2 AND THEN CALL ASCENDING SORT 
    
    
    P1: CALL BUBBLE_DESCENDING_SORT
    JMP PRINT_ARRAY     ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY 
    
    P2: CALL BUBBLE_ASCENDING_SORT  
    JMP PRINT_ARRAY     ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY
    


    T2: ;SELECTION TYPE
    ;CHOOSE THE TYPE OF ORDER ASCENDING OR DESCENDING
    CALL NEW_LINE
    MOV AH,9
    LEA DX,MESSAGE3
    INT 21H
    CALL NEW_LINE
    
    MOV AH,1
    INT 21H         ;enter a number
    SUB AL,30H 
    CMP AL,1      ;COMPARE INPUT WITH 1
    JB INVALID 
    JE P3    ;IF EQUAL JMP TO P3 AND THEN CALL DESCENDING SORT
    CMP AL,2      ;COMPARE INPUT WITH 2
    JA INVALID
    JE P4    ;IF EQUAL JMP TO P4 AND THEN CALL ASCENDING SORT 
    
    
    P3: CALL SELECTION_DESCENDING_SORT
    JMP PRINT_ARRAY    ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY
    
    P4: CALL SELECTION_ASCENDING_SORT  
    JMP PRINT_ARRAY    ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY
    
      
      
   T3: ;QUICK TYPE
    ;CHOOSE THE TYPE OF ORDER ASCENDING OR DESCENDING
    CALL NEW_LINE 
    MOV AH,9
    LEA DX,MESSAGE3
    INT 21H
    CALL NEW_LINE 
    
    MOV AH,1
    INT 21H        ;enter a number
    SUB AL,30H 
    CMP AL,1      ;COMPARE INPUT WITH 1
    JB INVALID 
    JE P5    ;IF EQUAL JMP TO P1 AND THEN CALL DESCENDING SORT
    CMP AL,2      ;COMPARE INPUT WITH 2
    JA INVALID
    JE P6    ;IF EQUAL JMP TO P2 AND THEN CALL ASCENDING SORT
    P5: CALL QUICK_DESCENDING_SORT
    JMP PRINT_ARRAY     ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY
    P6: CALL QUICK_ASCENDING_SORT  
    JMP PRINT_ARRAY     ;AFTER THE CALL OF THE PROCEDURE JMP TO PRINT_ARRAY
    
    
;================================================== 
    
    
 ;=======================================================
      
    ;PRINT AFTER SORTING
    PRINT_ARRAY:
    POP CX         ;POP THE NUMBER OF ELEMENTS FROM THE STACK INTO CX THAT U PUSHED IT ABOVE
    CALL NEW_LINE 
        
    MOV AH,9
    LEA DX,MESSAGE2     ;print message3
    INT 21H 
    
    
    MOV SI,0              ;START FROM INDEX 0
    PRINT_SORTED_ARRAY:
        MOV AH,2
        MOV DL,ARR[SI]   ;PRINT ARR[SI]
        INT 21H
        MOV DL,' '       ;PRINT SPACE
        INT 21H
        INC SI           ;INC SI FOR THE NEXT ELEMENT
        LOOP PRINT_SORTED_ARRAY
    JMP EXIT
;====================================        
    NO_INPUTS_MESSAGE:
        MOV AH,9
        LEA DX,MESSAGE6     ;print message6
        INT 21H
        CALL MAIN         ;CALL MAIN AGAIN 
        
;====================================         
    EXIT:
        MOV AH,4CH   ;END PROGRAM
        INT 21H
        MAIN ENDP


;==========================================================

BUBBLE_ASCENDING_SORT PROC
   ;THIS PROCEDURE WILL SORT THE ARRAY IN ASCENDING ORDER
   ;INPUT : SI=OFFSET ADDRESS OF THE ARRAY
   ;      : BX=ARRAY SIZE
   PUSH AX
	@@ -189,69 +214,69 @@ BUBBLE_DESCENDING_SORT PROC
   PUSH SI
   
   MOV AX,SI
   MOV DX,CX    ; NUMBER OF ELEMENTS INTO DX

  DEC CX       ;CUZ THE BUBBLE LOOP THE NUMBER OF ELEMENTS-1 ; for i = 0; i < n-1; i++         
  JCXZ BUBBLESORT_END     ;IF THERE IS ONE ELEMENT IN THE ARRAY EXIT THE PROCEDURE 
